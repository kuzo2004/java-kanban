package ru.yandex.practicum.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import ru.yandex.practicum.entity.*;
import ru.yandex.practicum.exceptions.TimeConflictException;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Iterator;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

abstract class TaskManagerTest<T extends TaskManager> {
    protected T taskManager;

    protected abstract T createTaskManager();

    @BeforeEach
    public void beforeEach() {
        taskManager = createTaskManager();
    }

    @Test
    public void testAddAndFindDifferentTaskTypes() {
        // Создаем задачи разного типа
        Task task = new Task("Task 1", "Description");
        Epic epic = new Epic("Epic 1", "Description");
        Subtask subtask = new Subtask("Subtask 1", "Description", epic, null, null);

        // Добавляем задачи в менеджер
        taskManager.addTask(task);
        taskManager.addTask(epic);
        taskManager.addTask(subtask);

        // ищем задачи с нужным типом
        Map<Integer, Task> tasks = taskManager.getAllTasksByType(TaskType.TASK);
        Map<Integer, Task> epics = taskManager.getAllTasksByType(TaskType.EPIC);
        Map<Integer, Task> subtasks = taskManager.getAllTasksByType(TaskType.SUBTASK);

        // проверяем поиск по типам
        assertNotNull(tasks, "Список TASK не пустой.");
        assertEquals(1, tasks.size(), "Список TASK не пустой и равен 1.");

        assertNotNull(epics, "Список EPIC не пустой.");
        assertEquals(1, epics.size(), "Список EPIC не пустой и равен 1.");

        assertNotNull(subtasks, "Список SUBTASK не пустой.");
        assertEquals(1, subtasks.size(), "Список SUBTASK не пустой и равен 1.");

        // ищем задачи по id
        Optional<Task> optionalActualTask = taskManager.getTaskById(task.getId());
        Optional<Task> optionalActualEpic = taskManager.getTaskById(epic.getId());
        Optional<Task> optionalActualSubtask = taskManager.getTaskById(subtask.getId());

        // проверяем поиск по id
        assertTrue(optionalActualTask.isPresent(), "Задача TASK должна быть найдена");
        assertTrue(optionalActualEpic.isPresent(), "Задача EPIC должна быть найдена");
        assertTrue(optionalActualSubtask.isPresent(), "Задача SUBTASK должна быть найдена");
    }

    @Test
    public void testTasksWithManualAndAutoGeneratedIdDoNotConflict() {
        // Создаем задачу с заданным id
        Task taskWithManualId = new Task(100, "Task with manual ID",
                "Description", Status.NEW, null, null);
        taskManager.addTask(taskWithManualId);

        // Создаем задачу с автоматически сгенерированным id
        Task taskWithAutoGeneratedId = new Task("Task with auto-generated ID", "Description 2",
                null, null);
        taskManager.addTask(taskWithAutoGeneratedId);

        // Проверяем, что обе задачи добавлены в менеджер
        assertEquals(2, taskManager.getAllTasks().size(), "В менеджере должно быть 2 задачи");

        // Проверяем, что задача с заданным id доступна по этому id
        Optional<Task> optionalFoundTaskWithManualId = taskManager.getTaskById(100);
        assertTrue(optionalFoundTaskWithManualId.isPresent(), "Задача с заданным id должна быть найдена");

        // Проверяем, что задача с автоматически сгенерированным id доступна по своему id
        Optional<Task> optionalFoundTaskWithAutoGeneratedId = taskManager.getTaskById(taskWithAutoGeneratedId.getId());
        assertTrue(optionalFoundTaskWithAutoGeneratedId.isPresent(),
                "Задача с автоматически сгенерированным id должна быть найдена");

        // Проверяем, что id задач не конфликтуют
        assertNotEquals(taskWithManualId.getId(), taskWithAutoGeneratedId.getId(), "ID задач не должны совпадать");
    }

    @Test
    public void testTaskImmutabilityAfterAddingToManager() {
        // Создаем задачу
        Task task = new Task("Task 1", "Des 1");
        int id = task.getId();
        String name = task.getName();
        String description = task.getDescription();
        Status status = task.getStatus();

        // Добавляем задачу в менеджер
        taskManager.addTask(task);

        // Получаем задачу из менеджера
        Optional<Task> optionalActualTask = taskManager.getTaskById(task.getId());
        assertTrue(optionalActualTask.isPresent(), "Задача с заданным id должна быть найдена");
        Task actualTask = optionalActualTask.get();

        // Проверяем, что все поля задачи остались неизменными
        assertEquals(id, actualTask.getId(), "Id задачи не должен измениться");
        assertEquals(name, actualTask.getName(), "Название задачи не должно измениться");
        assertEquals(description, actualTask.getDescription(), "Описание задачи не должно измениться");
        assertEquals(status, actualTask.getStatus(), "Статус задачи не должен измениться");
    }


    /**
     * Правило обновления эпик:
     * 1.Если есть хотя бы одна подзадача IN_PROGRESS → эпик IN_PROGRESS
     * 2.Если есть смесь статусов (не все NEW и не все DONE) → эпик IN_PROGRESS
     * 3.Если все подзадачи NEW → эпик NEW
     * 4.Если все подзадачи DONE → эпик DONE
     */
    @Test
    public void testEpicStatusCalculation() {
        // Создаем эпик и подзадачи
        Epic epic = new Epic("Epic 1", "Description");
        taskManager.addTask(epic);

        // Любая задача создается со статусом NEW
        Subtask subtask1 = new Subtask("Subtask 1", "Desc", epic, null, null);
        Subtask subtask2 = new Subtask("Subtask 2", "Desc", epic, null, null);
        taskManager.addTask(subtask1);
        taskManager.addTask(subtask2);

        //3.Если все подзадачи NEW → эпик NEW
        assertEquals(Status.NEW, epic.getStatus(), "Эпик должен быть NEW когда все подзадачи NEW");


        // 2. Если есть смесь статусов (не все NEW и не все DONE) → эпик IN_PROGRESS
        // Задачу можно редактировать только через обновление.
        taskManager.updateTask(
                subtask1.getTaskType(),
                subtask1.getId(),
                subtask1.getName(),
                subtask1.getDescription(),
                Status.DONE,
                subtask1.getStartTime(),
                subtask1.getDuration());

        assertEquals(Status.IN_PROGRESS, epic.getStatus(),
                "Эпик должен быть IN_PROGRESS когда есть подзадачи NEW и DONE");


        // 4.Если все подзадачи DONE → эпик DONE
        taskManager.updateTask(
                subtask2.getTaskType(),
                subtask2.getId(),
                subtask2.getName(),
                subtask2.getDescription(),
                Status.DONE,
                subtask2.getStartTime(),
                subtask2.getDuration());

        assertEquals(Status.DONE, epic.getStatus(), "Эпик должен быть DONE когда все подзадачи DONE");


        // 1.Если есть хотя бы одна подзадача IN_PROGRESS → эпик IN_PROGRESS
        taskManager.updateTask(
                subtask2.getTaskType(),
                subtask2.getId(),
                subtask2.getName(),
                subtask2.getDescription(),
                Status.IN_PROGRESS,
                subtask2.getStartTime(),
                subtask2.getDuration());

        assertEquals(Status.IN_PROGRESS, epic.getStatus(),
                "Эпик должен быть IN_PROGRESS когда хотя бы одна подзадача IN_PROGRESS");

    }

    @Test
    public void testSubtaskEpicRelationship() {
        Epic epic = new Epic("Epic", "Desc");
        taskManager.addTask(epic);

        Subtask subtask = new Subtask("Subtask", "Desc", epic, null, null);
        taskManager.addTask(subtask);

        Optional<Task> foundSubtask = taskManager.getTaskById(subtask.getId());
        assertTrue(foundSubtask.isPresent() && foundSubtask.get() instanceof Subtask,
                "Подзадача должна быть найдена");

        Subtask actualSubtask = (Subtask) foundSubtask.get();
        assertEquals(epic.getId(), actualSubtask.getParentEpic().getId(),
                "Подзадача должна быть связана с эпиком");
    }

    @Test
    public void testTimeOverlapDetection() {
        LocalDateTime baseTime = LocalDateTime.now();
        Duration duration = Duration.ofMinutes(60);

        Task task1 = new Task("Task 1", "Desc #1", baseTime, duration);
        taskManager.addTask(task1);

        // Пересекающаяся задача (совпадающее время)
        Task overlappingTask = new Task("Overlapping", "Desc", baseTime, duration.plusMinutes(30));
        assertThrows(TimeConflictException.class, () -> taskManager.addTask(overlappingTask),
                "Должно быть исключение при пересечении времени");

        // Непересекающаяся задача (после)
        Task nonOverlappingTask = new Task("Non-overlapping", "Desc",
                baseTime.plusMinutes(120), duration);
        assertDoesNotThrow(() -> taskManager.addTask(nonOverlappingTask),
                "Не должно быть исключения для непересекающихся задач");

        // Граничный случай - точно в конце первой задачи
        Task edgeCaseTask = new Task("Edge case", "Desc",
                baseTime.plusMinutes(60), duration);
        assertDoesNotThrow(() -> taskManager.addTask(edgeCaseTask),
                "Задачи, начинающиеся точно в конце других, не должны конфликтовать");
    }

    @Test
    public void testPrioritizedTasksOrder() {
        LocalDateTime earlyTime = LocalDateTime.now();
        LocalDateTime lateTime = earlyTime.plusMinutes(60);
        LocalDateTime middleTime = earlyTime.plusMinutes(30);
        Duration duration = Duration.ofMinutes(10);

        Task lateTask = new Task("Late", "Desc", lateTime, duration);
        Task earlyTask = new Task("Early", "Desc", earlyTime, duration);
        Task middleTask = new Task("Middle", "Desc", middleTime, duration);

        taskManager.addTask(lateTask);
        taskManager.addTask(earlyTask);
        taskManager.addTask(middleTask);

        Set<Task> prioritized = taskManager.getPrioritizedTasks();
        Iterator<Task> iterator = prioritized.iterator();

        assertEquals(earlyTask, iterator.next(), "Первой должна быть более ранняя задача");
        assertEquals(middleTask, iterator.next(), "Второй должна быть промежуточная задача");
        assertEquals(lateTask, iterator.next(), "Третьей должна быть более поздняя задача");
    }

    @Test
    public void testTaskDeletionFromPrioritizedTasks() {
        Epic epic = new Epic("Epic", "Desc");
        taskManager.addTask(epic);

        Subtask subtask = new Subtask("Subtask", "Desc", epic,
                LocalDateTime.now(), Duration.ofMinutes(10));

        taskManager.addTask(subtask);

        //проверяем наличие подзадачи в Отсортированном списке задач
        Set<Task> prioritized = taskManager.getPrioritizedTasks();
        assertTrue(prioritized.contains(subtask),
                "Подзадача должна быть в отсортированном списке");


        // Удаляем подзадачу
        assertTrue(taskManager.deleteTask(subtask), "Удаление должно возвращать true при успехе");
        assertFalse(taskManager.getTaskById(subtask.getId()).isPresent(),
                "Подзадача должна быть удалена из общего списка задач");
        assertFalse(epic.getSubtasks().containsKey(subtask.getId()),
                "Подзадача должна быть удалена из эпика");
        assertFalse(prioritized.contains(subtask),
                "Подзадача должна быть удалена из отсортированного списка задач");


        // Удаляем эпик
        assertTrue(taskManager.deleteTask(epic), "Удаление эпика должно возвращать true");
        assertFalse(taskManager.getTaskById(epic.getId()).isPresent(),
                "Эпик должен быть удален");
    }
}

